# 2017년 08월 20일 일요일
---
# 1. key point
## 자바스크립트 아키텍처, 메커니즘
## 자바스크립트 엔진 처리
## 가장 중요한 것은 기본
---
# 2. 진행 방법
## 개념, 논리, 기능 설명
## 예제 코드 코딩
## 자료, 소스 코드 배포하지 않음
## 질의 응답
---

# 3. javaScrip핵심
## 1) DOM
## 2) HTML API (file 등)
## 3) 그래픽
## 4) 통신

---

# 4. function object
- 빌트인(built-in) Function 오브젝트
  - 내장 함수??라고 하기에는 좀 이상하다.
  - function.prototype.call(){}
- Function 오브젝트
  - function book(){}
  - **위 문구를 실행하면 빌트인 function 오브젝트를 실행한다..?**
- function 인스턴스
  - new Book(), new 사용(**new를 사용한다는 것은 빌트인오브젝트를 가지고 오브젝트를 만든후 인스턴스를 만든다.**)
  - Book.prototype 사용
> javascript 는 다른 언어와는 달리 new연사자를 쓰지 않아도 엔진이 function을 알아서 인식한다. 그것이 바로 built-in function object 이다. (Array 오브젝트, Object 오브젝트 등등....)
- 함수 호출 코드 예
  - `var sports = function(){}`
  - `sports()`
- 엔진이 function 키워드를 만나면
  - 빌트인 function 오브젝트의
  - prototype에 연결된 프로퍼티로
  - Function 오브젝트 생성(메모리에 올림) **(엔진이 function 오브젝트를 만드는데, 그 이름은 sports이다.)**
  - 인스턴스 개념
- 생성한 오브젝트를 sports변수에 할당
- sports함수 호출
  - Function오브젝트이므로 호출가능

# 5. 객체지향 언어
- 자바스크립트는 객체 지향 프로그래밍 언어
  - OOP: **Object-Oriented Programming**
  - [naver](www.naver.com)
- function 오브젝트를 독립된 객체로 인식, 접근
  - 객체는 객체 하나로 끝나야 한다. 객체안에 여러 기능이 있으면 안된다?. 함수는 객체이다.
- OOP 개념 이해 필요
  - module은 뭔지, componant는 무엇인지.(Angular, React는 module, componant개념이다.)


> - 날코딩을 안한다 할지라도 개념은 이해하고 가야 하지 않겠니?
> - 자바스크립트를 몰라도 제이쿼리만 알면 개발 할 수 있다라는 개념은 자바스크립트가 객체 지향이기 때문이다. 다른 언어는 클래스 개념이기 때문에 상속 부터 해야 하는데, 그럼 설계를 먼저 해야 한다. (상속에 관한 MAP). 리엑트나, 엥귤러는 모듈, 컴퍼넌트개념이기 때문에 완전 다른 개념이다. 설계가 꼭 필요하다. 하지만 자바스크립트는 설계가 아니라 쫙 뿌려놓고 하나씩 골라 가지는 것 이기 때문에 설계까 많이 필요하지 않다. 왜냐하면 리엑트 같은 경우 이벤트를 하나 만들어 놓고 가져다 쓰는 개념이기 때문이다??


> - 자바스크립트는 상속을 가지고 개발하는 경우가 많지 않다.But. ES6로 가면 그렇지 않다.

# 6. 오브젝트 저장
- 호출하려면 생성한 Function 오브젝트 저장 필요
- 오브젝트 저장 형태
  - function 키워드로 생성한 Function 오브젝트를
  - (key: value)형태로 저장
  - {sports: Functoin 오브젝트} 형태
> 이러한 저장구조가 정말 많은곳에 영향을 미침
- 함수를 호출하면 (`sports()`)
  -  함수이름으로 저장된 오브젝트 검색
  -  value값을 구하고
  -  value가 Function오브젝트이면 호출
> 다른 언어라면 compile해야 하니까 컴파일 당시에 sports가 함수인지 아닌지 알아야 하지만, javascript는 일단 이름으로 sports로 읽어 보고 그 값이 함수이면 함수로 인식, number이면 number로 인식한다. ()가 있으면 함수인지 판별하고 함수이면 실행한다. 이러한 측면이compile 언어와 완전 다른 부분읻.

# 7. 생각 전환
- 함수가 호출되면 자바스크립트 엔진은
  - key:value형태의 프로퍼티를 조합하여 (**프로퍼티라는 것은 {key:value} 한세트를 의미한다**)
  - 실행환경을 인식하고
  - 함수코드를 실행한다.
- {key:value} 형태에 맞추어 생각을 전환해야 한다.
  - 자바스크립트의 근본에 쉽게 접근할 수 있다.
  - 아키텍처와 메커니즘을 이해할 수 있따.
- function(){}코드를 보면
  - key:value형태의
  - function 오브젝트가 연상되어야 하며
  - function오브젝트의 프로퍼티가 연상되어야 한다.

# 8. 아키텍처, 메커니즘
- 아키텍쳐: Architecture
  - 목적을 가진 구조
  - 자바스크립트 목적을 달성하기 위한 구조
- 메커니즘: Mechanism
  - 목적을 달성하기 위한 방법
  - 목적에 따라 방향, 방법, 기준이 달라질 수 있음
- 아키텍처와 메커니즘에 대한 정환한 이해
  - 목적과 방법을 모르고 개발하면 안된다!!!!

# 9. 자바스크립트의 목적
- 자바스크립트는 프로그래밍 언어
- 언어의 목적은 소통
- 자바스크립트 프로그램의 목적
  - 프로그램을 통해 자바스크립트와 소통
  - 문법을 지켜야 소통 가능
  - 문법은 기본을 지키는 것
- 자바스크립트와 소통
  - 자바스크립트 상태 파악
  - 아키텍처와 메커니즘 이해

# 10. ES3 키워드 리스트
- ES3 스펙 목차
  - 아키턱처, 메커니즘 관련 키워드 리스트

> - ES3에서 ES5는 아키텍쳐 메커니즘이 완전히 바뀌어 버렸다.
> - ES5는 꼭 알아야 한다.

# 11. ES5 키워드 리트스
- ES5 스펙 목차
  - 아키텍처 메커니즘 관련 키워드 리스트 (ES5 스펙중 10장 내용)


```
10. Executabel Vode and Execution ontexts
10.1  Types of Excutable Code
  10.1.1 Strict Mode Code
10.2 Lexical Environments
  10.2.1 Environment Records
  10.2.3 The Global E/nvironemtns
  10.3 Execution Contexts
  10.3.1 Identifier Resolution
  10.4......
```

# 12. Function 오브젝트 생성 순서, 방법
1. function 오브젝트 생성
  - {코드} : function sports(){} (엔진이 만듬)
  - sports는 생성한 function 오브젝트 이름
  - 오브젝트 타입이 "function"이면 빈 오브젝트 (이때 객체는 구체적인 function을 말한다.)
  - 지금부터 아래 처리를 통해 빈 오브젝트를 채운다.
```
**function sports()를 코딩하고
  - 개발자 도구 창에서 sports오브젝트 모습을 보세요
```
2. sports오브젝트에 prototype 오브젝트 첨부
3. protyotype에 constructor 프로퍼티(key=constructor) 첨부
(**하위 Depth도 상위의 내용을 참조 할수 있도록 항상 Constuctor가 첨부 되는 것 같다.**)
> constructor가 1depth에 없고 prototype밑에 있는 이유는 그러한 이유가 있다.


4. prototype 에서 sports오브젝트 전체를 참조할 수 있도록 설정
5. prototype 에 __proto__오브젝트 첨부
  - ES6 스펙에서 __proto__정의
  - ess5 기준으로 보면 표준이 아님
> __proto__ 는 'geeter', 'setter' 이다. 하지만 __proto__는 엔진이 쓰려고 만든 거라서, 잘 쓰지 않는다. 만약 prototype을 설정하려면 prototype에 설정을 해서 써라. 그럼 __proto__로 갈 것이다. 즉, prototype은 __proto__의 원본인 격이 될 것이다.
> 예전에는 __proto__에 직접 프로퍼티를 설정하였으나, 지금은 그러지 말자!
6. 빌트인 Object오브젝트의 Prototype에 연결된 프로퍼티로 (**Obejct.prototype: {...}**)
  - Object인스턴스를 생성하여 Prototype.__proto__에 첨부
  (인스턴스를 만든다는 건 Object.prototype만 가지고 있고, Objet가 가지고 있는 porotype (Objec.~~ 는 제외하고)**6개이다.** __로 되어 있는 건 내부관리용이니까 몰라도 된다. )
7. sports오브젝트에 __proto__오브젝트를 첨부
  - sports.__proto__구조가 됩니다.
8. 빌트인 function오브젝트의 prototype에 연결된 프로퍼티로
  - Function 인스턴스 생성
(**Function.prototype.call/apply/bild**)
(인스턴스를 만든다는 것은 prototype에 연결될 만을 가져온다는 것을 의미한다.)
9. 생성한 Function 인스턴스를 sports.__proto__에 첨부
10. sports오브젝트 프로퍼티에 초기값 설정
- arguments, cller, length, name 프로퍼티 (function에 들어가는 프로퍼티!)

# 13.실행환경 인식
- 실행환경 인식 필요성
  - 함수가 호출되었을때 실행될 환경을 인식할 수 있어야
  - 실행 환경에 맞추어 실행할 수 있음
  - 환경 (파라미터, 어디서돌아가는지(scope)등)을 어디에든 저장해 놓아야 한다.
- 실행 환경 설정 시점
  - Function 오브젝트를 **생성하는 시점**에 환경 설정
    (함수를 생성한후 코드 밑으로 내려가버리면 환경을 모른다.)
  - 예:함수에 작성한 코드, 파라미터, 실행 영역 등
  - Function 오브젝트를 생성하고 바로 실행하는 것이 아니므로
  - 함수가 호출되었을때 사용할 수 있도록 환경저장 필요
- 어디에 저장???
  - 생성한 Function Object에 저장
  - (name:value)형태
  - 인식한 환경을 Function 오브젝트의 **내부 프로퍼티**에 설정
  (내부프로퍼티는 내부의 엔진이 쓸 프로퍼티??)
  - 즉, 한번만 불러 내면, 어디에있고, 파라미터는 뭐가 있고, 어디에 속해있고, 어디에서 실행될지

# 14. 내부 프로퍼티
- 내부프로퍼티란?
  - 엔진이 내부 처리에 사용하는 프로퍼티
  - 스펙상의 사양으로 외부프로그램에서 접근 불가
- 표기
  - ``[[]]`` 의 형태 `[[scope]]`

# 15.내부프로퍼티 분류
- 공통 프로퍼티, 선택적 프로퍼티
- 공통 프로퍼티
  - 모든 오브젝트에 공통으로 설정되는 프로퍼티
- 선택적 프로퍼티
  - 특정 프로 퍼티

# 16. 공통 내부 프로퍼티
- 모든 오브젝트에 설정

```
[[Prototype]]-object또는 Null-오브젝트의 Prototype
(json, MATH같은건 prototype이 없다. 인스턴스를 안만들거니까. 인스턴스를 만들 수 없으니까.)
[[Class]]-String-오브젝트의 유형구분 (Array, Object, Number 등)
[[Extensible]]-Boolen-오브젝트에 프로퍼티 추가 가능 여부
[[Get]]-any-이름을 가진 프로퍼티 값을 반환
[[GetOwnProperty]]-프로퍼티 디스크립터, undefined-오브젝트 소윺의 프로퍼티 디스크립터 속성 반환
[[GetProperty]]-프로퍼티 디스크립터, undefined-오브젝트의 프로퍼티 디스크립터 속성 반환
[[put]]-''-프로퍼티 이름의 값 설정
[[CanPut]]-Boolean-값의 설정 가능여부 반환
[[HasProperty]]-Boolean-프로퍼티 존재 여부 반환
[[Delete]]-Boolean-오브젝트에서 프로퍼티 이름 삭제 가능여부
[[DefaultValue]]-any-오브젝트의 디폴트 값 반환
[[DefinedOwnProperty]]-Boolean-오브젝트에 프로퍼티 추가, 프로퍼티 값 변경

**'Own'이라는 개념은 상속받은것 제외. 자기 자신이 만든거**
```

# 17. 선택적 내부 프로퍼티
- 오브젝트에 따라 선택적 설정

```
[[PrimitiveValue]]-프리미티브값-Boolean, Date, Number, String 오브젝트에서 제공
[[Construct]]-오브젝트-new연산자와 함께 인스턴스를 생성하여 반환
[[Call]]-any-함수호출
[[HasInstaqnce]]-Boolean-오브젝트에 의해 생성한 인스턴스 여부를 반환
[[Scope]]-렉시컬 환경-function 오브젝트가 실행되는 렉시컬(정적)환경
[[FomalParameters]]-문자열 리스트-호출된 함수의 파라미터 이름 리스트
[[Code]]-자바스크립트 코드-함수에 작성된 자바스크립트 코드가 설정되며 함수가 호출되었을때 실행
[[TargetFunction]]-Object-Function오브젝트의 bind메소드에 생성된 타깃 함수오브젝트 설정
[[BoundThis]]-any-function오브젝트의 bind메소드에 생성된 함수 오브젝트에 바인딩 된 this오브젝트
[[BoundArguments]]-리스트-function오브젝트의 bind메소드에 생성된 함수 오브젝트에 바인딩 된 아규먼트 리스트
[[Mathc]]-매치 결과-정규표현식의 매치 결과
[[ParameterMap]]-Object-아규먼트 오브젝트와 함수 파라미터의 프로퍼티 매핑
**자바스크립트는 function(){}을 만나면 function Object를 만들지만, 함수 내부에는 들어가지 않는다!!!!. 그리고 함수를 호출하면 함수 내부의 코드를 읽는다. 하지만, 다른 언어는 컴파일 과정에서 함수 내부의 코드에 접근한다. 이러한 맥락에서 [[Code]]라는 선택적 내부 프로퍼티가 존재한다. 이러한 이유는 예를 들면 회원가입을 할때, 회원가입을 눌렀을 때만 해당 JS가 실행된다. 하지만 일반적인 다른 언어는 컴파일 할때마다 실행하지...렌더링 시간을 단축한다**
```

## 18.함수 정의
- 함수정의 (Functoin Definitaion)
  - 함수가 실행될 수 있도록
  - 자바스크립트 문법에 맞게 작성하는 것
- 함수정의 형태
  - 3개 형태로 함수를 정의 할수 있음
    - 함수 선언문 (Function Declaration)
    - 함수 표현식 (Function Expression)(1+1, 1/1, return 등.)
    - new function (param1, para2, body)
    - (문자열로 작성)

## 19.함수 선언문
- 함수 선언문
```javascript
function myHomew(book){
  return book;
}
```
## 20. 함수 표현식
- 함수를 항할당해주는것
- 식별자는 선택. 식별자를 작성하여도 변수 이름이 함수 이름이 됨. 식별자 작성 후 식별자로 함수 호출 하면 애러. 식별자는 자기자신 함수 안에서 만 쓸수 있다.
- 즉, 식별자 쓰지 마라
```javascript
var outside = function inside(param){
  if(param === 102){
    return param;
  }
  return inside(para +1)
}
console.log(outside(100))
```

1. inside 이름을 Function오브젝트를 생성하여 outside에 할당합니다.
2. 함수 밖에서 inside()로 함수를 호출하면 에러가 발생하므로
   - outside()로 호출하여야 하며
   - 함수 안으로 이동한 후 inside()로 호출 할 수 있습니다.
3. 함ㅎ수 안에서 inside()함수를 호출하는 것은 자신을 호출하는 것이며
   - 무한으로 호출하게 되므로
   - 함수가 종료되도록 취해야 합니다.
4. 자신을 호출하는 형태를 재귀함수라고 합니다.
5. 함수 안에서 outside()를 호출할 수 있으므로
   - inside를 사용하지 않아도 됩니다.

**함수 표현식을 할때는 보통 name space를 위해 사용한다. / 그럼 일반적으로 표현식으로만 쓰면되지 않나요? / 네네... 쓰세요.**
**함수를 하나씩 쓸때는 선언문을 쓰세요**
```javascript
namespace.a = function(){}
namespace2.a = function(){}
```
## 21. 엔진해석
- 자바스크립트는 스트립팅 언어
  - 스크립팅 언어는 작성된 코드를 위에서부터 한줄씩 해석하지만
  - 자바스크립트는 차이가 있음 (한줄씩 안하고 붕붕 뜰! 수! 도! 있! 다!)
- 함수 형태에 따라 해석 순서가 다름
  - 중간에 있는 코드가 먼저 해석될 수 있음
- **함수 선언문 먼저 해석!!!!**
  - function sports(){};
- 함수 표현식 해석
  - var sports = function(){};

## 22. 함수 해석 순서
```js
//함수 선언문
function sports(){
  debugger;
  var player = 11;

  function soccer(){
    return player;
  }

  //함수 표현식
  var baseball = function(){};
  soccer();
}
```

//코드 작성 형태
1. player 변수 선언
  `[코드] var player = 11;`
2. 다음에 함수 선언문 작성
  `[코드] function soccer(){return plyer;}`
3. 다음에 함수 표현식 작성
  `[코드] var baseball = function(){};`
4. 마직막 줄에서 soccer 함수 호출
  `[코드] soccer();`

//자바스크립트 엔진 처리 순서
1. 마지막 줄에서 sports함수를 호출하면
   - 두 번째 줄의 debugger에서 실행이 멈춥니다.
2. 이때,
   - player와 baseball값은 undefined이고
   - soccer는 function soccer()가 된다.
   - 개발자 도구 창에서 확인 가능
3. 첫번째 줄에서 멈추어쓴데
   - soccer에 function오브젝트가 설정된 것은
   - function soccer(){}문장을 해석한 것을 의미합니다.
4. 또한 player 와 baseball에 설정된 undefined도 값이며
   - 해석한 것을 의미합니다.
   - 해석하지 않았다면 player와 baseball자체가 표시되지 않습니다.
5. baseball은 현재 변수만 선언된 상태이며
   - 다음에...계속....

## 23.코드 해석 단계(중요!)
- 함수 선언문 해석(첫번째 내려가기,해석이라는 것은 key:value로 만든다는 것이다.)
  - function sports(){}
- 변수 초기화(다시 올라온다.(두번째 내려가기) 값은 undefined. **함수 선언문은 해석부터 함수 인데, 표현식은 함수도 아니다. (그냥 변수취급)** )
  - var sports
  - var member
- 자바스크립트 코드 실행(다시 올라온다(세번째 내려가기))
  - debugger;
  - var sports=function(){}
  - var member = 123;

## 24. (1)함수 선언문 해석
- 함수 선언문 초기화
- 마지막 줄에서 sports함수를 호출합니다.
  `(코드)sports();`
- 엔진 제어가sports


## 25.(2)변수 초기화
-debugger를 실행하지 않는다.
- player 변수에 초기값으로 undefined를 할당한다.
- baseball변수에 undefined를 할당한다


## 26. (3)코드 실행
- 순서대로 실행한다. **만약 내부에 또 함수가 있으면 3번도는 걸 또한다.**

## 27. 함수 앞에서 호출
- 함수 선언문은 초기화 단계에서
  - function 오브젝트를 생성하므로
  - 함수를 호출하는 위치에 영향을 받지 않음
- **함수 앞에서 호출 가능**
```js
function sports(){
  baseball();
  function baseball(){console.log("baseball")}
}
```
- 호이스팅 (Hoisting)
  - 용어보다 개념으로 접근
  - **이것이 바로 호이스팅!!!!!!!함수 선언문만 가능하다!!!**

>중요한건 자바스크립트가 해석될때 함수는 세번 내려간다!!!!!!!


## 28. 함수선언무 오버라이딩
- 오버라이딩
  - 함수 이름이 같을 때 함수 코드를 대체한다.
- 자바스크립트는
  - 파라미터 수 , 데이터 타입 체크하지 않음
  - `{key:value}`로 저장하기 때문
- 상황
  - 초기화 단계엑서 함수 선언문을
    - function 오브젝트로 생성
  - 아래에 이름이 같은 함수 선언문이 있으면
    - 아래에 작성한 함수 선언문이 호출 됨


## 28.1 함수 선언문 오버 라이딩
```js
function sports(){
  function soccer(){
    console.log("축구")
  }
  //여기서 호출
  soccer();

  //이놈이 호출됨
  function soccer(){
    console.log("축구2")
  }
}
```

## 29. 코딩 시간
- 함수 오버라이딩
- 시나리오:함수의 이름이 같으며 가운데에서 함수 호출
  1. 선언문, 호출, 선언문
  2. 표현식, 호출, 표현식
  3. 선언문, 호출, 표현식
  4. 표현식, 호출, 선언문

**3번에서 처음에 선언문으로 값,밸류가 있는상태에서 표현식으로 undefined를 넣을려고 해도 undefined가 설정되지 않는다. 이미 값이 있는 경우는 초기화를 하지 않는다.**

**겁나신기한거!!!!**
```js
var test = "aa"
function test(){}
로하면 test에 함수로 덮어 씌어진다. 그 이유는 어자피 모든건 key:value 값으로 저장하기 때문이다! var든 funtion이든
```
## 30. 함수 파라미터
- 파라미터 상호관계
  - 호출하는 함수 : 값 전송
  - 호출받는 함수 : 이름으로 받음
- 파라미터 작성
  - 호출받는 함수의 파라미터에 이름 작성
  - 호출하는 함수의 파라미터에 값 작성
- 파라미터 값 처리
  - 호출한 함수에서 보낸 값을
    - 인덱스로 매칭

## 31. 파라미터 이름 작성 목정
- 이름으로 값 사용
  - 함수 안에서 팔미터 이름으로 값을 사용
- 가독성을 위한것
  - **엔진은 파라미터 순서로 값 매핑**

> 코드를 읽는 스타일에 대하여, 선생님은 코드보다 주석이 더 많다.
> 코드보다 주석이 많아야 되는 이유는 18일차에 알려 드림!!! (지금은 5일차)


## 32. 함수 파라미터
- 마지막 줄에서 get함수를 호출하면서 123과 456을 넘긴다.
- 첫번째 줄의 get()함수가 실행되면서 함수의 파라미터 순서에 맞추어 매핑한다

## 33. 파라미터 값 매핑
- 순서대로
- 파라미터 수가 다를 때도 호출이 가능하다.
  - fn(one){};
  - fn(12, 34, 56)
  - 다른 언어는 호출이 안되지만 자바스크립트는 가능하다.
  - **왜냐하면 key:value로 저장하기 때문이다. key는 `fn`이고 value는 `function Object`니까 그냥 불러 진다.**
- 호출 받는 파라미터 기준으로 값 매칭
- 호출 받는 파라미터 이름수가 작으면
  - 왼쪽엫서 오른쪽으로 값 설정
  - 매핑하지 못하면?
- 호출받는 파라미터 이름 수가 많으면?
  - 매핑하지 못한 파라미터에는 undefined로 설정된다.

## 34. arguments
- 아규먼트 오브젝트
  - 호출한 함수의 파라미터 값 저장
  - 호출한 함수의 파라미터에 작성한 순서로 저장
  - 호출한 함수에 파라미터를 작성하지 않아도 생성
- arguments로 접근
  - 호출받은 함수 안에서만 사용 가능
  - ex) `arguments[1]`

## 35. 아규먼트스 장단점
- 파라미터에 이름 작성
  - get(qty, price){}의 형태
  - qty는 수량이고 price는 단가
  - 이름으로 쉽게 인식할 수 있으며
  - 코드 가독성이 높음
- **파라미터 수가 고정일 때**
  - 파라미터 이름 사용
- **파라미터 수가 유동적일때**
  - arguments 사용
  - 함수 파라미터에 이름이 있으면 값 설정
  - 즉, 파라미터와 arguments에 모두 설정

## 36. arguments.length 프로퍼티
- 호출한 함수의 파라미터 수
  - get(1,2,3): 3개
  - get ([4,5], 4): 2개 (배열은 하나로 친다!(은근 중요))
- 사용형태
  - `arguments.length`
- Array-like
**arguments 는 배열이 아니라,유!사!배!열! 입니다.**
- 유사배열을 하는 이유는 `length`프로퍼티가 있기 때문이다!!!

## 37. length 프로퍼티(2)
- 기본적으로 length가 있다는 것은 for문을 돌리수 있다라는 뜻이다.

```js
var get = function (one) {
  console.log("arguments:",arguments.length)
});

console.log("파라미터 수 :")
```

## 38.arguments값 반환
- 호출한 함수의 파라미터 값 작성 형태
  - 문자열, 숫자, 배열, 오브젝트 등
- arguments 메커니즘
  - 파라미터 순서를 0부터 인덱스를 부여하여 key로 사용하고
  - 파라미터로 받은 값을 value에 설정
  - (0:value, 1:value)
- 결론 for()문 사용
  - 파라미터가 배열일때 for~in문으로 읽으면
  - **length프로퍼티를 제외시키는 코드가 필요하기 때문???**
  - for는 length 프로퍼티를 사용하면 되니까

## 39. 엔지 처리
- 엔진의 파라미터 처리 단계
    - 함수 호출
    - 파라미터 값 할당
    - 아규먼트 오브젝트 생성 (0: value, 1:value)
    - 함수코드 실행

1. get함수호출
2. 호출된 함수의 파라미터 수만큼 반복하면서 파라미터 값을 이름에 할당
3. arguments 오브젝트 생성
4. 빌트인 Object오브젝트를 인스턴스 형태로 상속받아, arguments 오브젝트에 첨부한다.(만약 arguments가 Array면 Array 오브젝으를 인스턴스 형태로 상속 받아 arguments오브젝트에 첨부한다.)
5. ........

## 40. Scope(여기부터 또 중요!)
- 스코프
  - 함수가 실행되는 영역
  - 함수가 실행될 때 영향을 받는 범위
- split()의 스코프
  - split()는 String 오브젝트에 존재하므로
    - String 오브젝트가 스코프
  - Number오브젝트에서 split()를 호출하면 에러발생
    - Number오브젝트에는 split()가 없기 때문
    - 즉, Number 오브젝트 스코프에 splite()가 없기 때문이다.
  - 'abc'.split('')에서 'abc'로 String오브젝트 생성
  - String 오브젝트가 이 스코프가 된다


## 41.스코프 사용 목적
- 범위 제한
  - 신속한 검색/접근
- 같은 프로퍼티 이름 사용가능
  - String의 indexOf()
  - Array의  indexxOf()

## 42.스코프의 구조
- 스코프 구조
  - 계층적 구조
  - 스코프 안에 스코프가 있는 형태
- 스코프 설정 시점
  - Functoin오브젝트를 생성할 때 (**아주 중요한 개념!!!!!!, 함수를 호출할때 스코프를 만들지는 않는다. (두개만 빼고)**)
  - 함수를 호출할 때 설정하지 않음
  - function 안의 코드에 대해서는 구조를 만들지 않음
- 스코프 구조 형성 방법
  - 밖에서 안으로 들어가면서 스코프 구조 형성
  - 안에서 밖으로 나가면서 스코프 범위 검색

**함수를 실행하기 전까지는 함수 안에 뭐가 있는지 모른다.**
**즉 함수 안에 함수가 있을때는 함수를 실행 시켜야 스코프를 확인 할 수 있다??**


## 43. 스코프 구조
```js
//소스 코드를 코딩
function sales(){
  debugger;
  function get(){
    function discount(){};
  discount();
  }
  get();
};
sales();
```

1. 엔진이 첫번째 줄의 function sales(){}를 만납니다.
2. sales Function오브젝트를 생성하고 스코프를 설정합니다.
    - Function 오브젝트의 내부 프로퍼티인
    - `[[scope]]`에 스코프를 설정합니다.
3. sales함수 안으로 들어가지 않고 아래로 내려값니다.
   - 함수 코드를 Function오브젝트의 `[[Code]]`에 설정하며
   - 함수안의 코드는 해석하지 않습니다.
**이 개념은 자바스크립트의 중요한 메커니즘입니다.**

4. 마지막 줄의 sales();를 만나 sales함수를 호출 합니다.
5. 엔진이 sales 함수 안으로 이동 합니다.
6. sales함수 안의 첫 번째 줄부터 해석하며
   - function get(){}을 만나게 됩니다.
7. get Function 오브젝트를 생성하고,
   -Function 오브젝트의 `[[Scope]]`에 스코프를 설정합니다.
8. get함수 안으로 들어가지 않고 아래로 내려값니다.
9. get()을 만나게 되어 get함수를 호출합니다.
10. 엔진제어가 get함수 안으로 이동합니다.
11. get 함수 안의 첫번째 줄부터 해석하게 되며
    - function discount(){}를 만나게 됩니다.
12. discount function 오브젝트를 생성하고
    - 스코프를 `[[Scope]]`에 설정 합니다.
13. discount 함수 안으로 들어가지 않고,
14. discount()를 만나게 되어 discount를 실행한다.



## 44.글로벌 오브젝트
- 글로벌 오브젝트는 프로그램의 시작점
  - 빌트인 오브젝트주에 하나(엔진이 쓰는거)
- 글로벌 오브젝트 특성
  - 전체 프로그램을 통해 하나만 존재
    - 전체 프로그램: 모든 `<script>`에 작성한 코드
  - 오브젝트 이름을 작성하지 않고
    - 함수를 호출하면 글로벌 오브젝트로 간주한다. (window.console.log()등)
    - ES6 `strict`모드에서는 꼭 window.을 써야 한댜.
- 글로벌 오브젝트 생성
  - 첫번째 `<script>`에서 한번만 생성
    - 자바스크립트 실행환경 설정
  - `<script>`의 프로그램 실행 전에 생성
- new 연산자 사용 불가

## 45. 글로벌 스코프
- 전체를 통해 하나만 존재하므로
  - 스코프도 하나
  - 글로벌 오브젝트와 글로벌 스코프가 같음
  - 글로벌 스코프이므로 모든 프로그램에서 사용가능
- 최상위 스코프
  - 최종 검색 스코프
  - 검색한 프로퍼티가 없으면 undefined반환
- 스코프 설정
  - Function 오브젝트 만들어질때 Function 오브젝트의 `[[Scope]]`에 설정
**어찌됬든 모든건 오브젝트 안에 key:value로 존재 해야 한다. 즉, 속해 있는 오브젝트가 없으니까, 자동으로 생성된 글로벌 오브젝트(window.)에 속해지는 것이다.**
**글로벌 오브젝트에 설정된다는 것은 사람의 관점으로 엔진관점은 Function 오브젝트의 `[[Scope]]`값이 글로벌 오브젝트라는 것이다.**

## 46.글로벌 함수
- 함수 구분
  - 글로벌 함수 : 전역 함수
  - 로컬함수 : 지역 함수
- 글로벌 함수
  - 글로벌 오브젝트에 작성한 함수
- 지역함수
  - 함수 안에서 var키워드를 사용한 함수와 함수 선언문
  - 함수 안에서 var키워드를 사용하지 않으면 글로벌 함수
  - strict모드일때: var를 사용하지 않고 함수를 선언하면 애러
  - 글로벌 오브젝트에서 var키워드를 사용하여 함수 선언 가능
- 권장
  - 글로벌, 지역에 관계없이 함수 표현식 함수는 var를 사용

## 47. 글로벌 변수
- 변수 구분
  - 글로벌 변수
  - 로컬변수
- 글로벌 변수
  - 글로벌 오브젝트에 작성한 변수
- 지역변수
  - 함수 안에서 var키워드를 사용한 변수
  - 함수안에서 var키워드를 사용하지 않으면 글로벌 변수
  - strict모드일때 var를 사용하지 않고 변소를 선언하면 에러
  - 글로벌 오브젝트에서 var키워드를 사용하여 변수 선언 가능
- 권장
  - 글로벌, 지역에 관계 없이 var키워드를 사용하여 변수 선언

## 48. 지역함수
- 지역 함수의 목적
  - 함수안에서 검색
  - 검색처리의 최적화
- 함수호출
  - 글로벌 함수
    - 어느위치에서도 함수 호출
  - 지역함수
    - 함수안으로 들어가야 함수 호출 가능

## 49. 지역변수
- 지역변수 목적
  - 함수 안에서 검색
  - 검색 처리의 최적화
- 변수 사용
  - 글로벌 변수
    - 어느위치에서도 변수 사용가능
  - 지역 변수
    - 함수안으로 들어가야 변수 사용가능
    - 함수외부에서 직접 사용 불가

## 50. Strinct 모드
1. 'use strict'선언
2. `insde='local'`;
  - 함수 안에서 var키워드를 사용하지 않고
  - 변수를 선언하면 에러발생
  - 실행 결과에 값이 출력되지 않은 것은 에러가 발생했기 때문
3. 브라우저 콘솔 창에
  - 에러 메시지가 표시된것을 확인 할수 있음

```js
'use strict';
 var outside~~~

```

## 51. 바인딩
- 바인딩
  - 구조적으로 결속된 상태로 만드는것
  - 대상: 오브젝트와 프로퍼티 이름
```js
// 아래처럼 get이라는 Object로 qty와 price를 묶었다.
var get ={
  qty:value,
  price:value
}
```
- 바인딩 목적
  - 스코프 결정
  - 스코프에서 이름 식별 -> 식별자 해결이라고 함
- 바인딩 시점 분류
  - **정적 바인딩 (Lexical, Static Binding)**
    - (여지껏 배운거? 함수 생성 시에 Scope를 결정 한다.)
  - **동적 바인딩 (Dynamic Bindig )**
    - (with all, 같은거)

## 52. 스코프 체인
- 스코프 체인
  - 스코프가 상하 구조로 연결된 개념/구조
  - 스코프 체인을 사용하여
    - 근접한 스코프에서 프로퍼티(함수, 변수)검색
  - ES3에서 사용 (ES5에서는 삭제!!!!!!)
- ES5에서 Scope chain개념 폐지
  - 렉시컬 환경 (Lexical Envionment 개념 사용)**다음주에 다룰 내용이다**
  - **Functoin Object에 내가 속한 놈이 어디야?? 하는 걸 가지고 있는 전체 맵이 스코프 체인인데, 렉시컬 환경은 바로 위의 놈만 누군지 파악하게 한다???**
**스코프 체인을 위한 매핑?은 함수가 호출될때마다 했어야 했다. 왜냐하면 함수 생성시에는 함수 안에 어떤함수가 있는지? 어떤 내용이 있는지 모르니까**


## 53. 바인딩 시점
- 정적 바인딩
  - 초기화단계에서 바인딩 (함수의 초기화단계는 2개가 있다. 함수/변수)
    - 함수 선언문 이름 바인딩
    - 변수, 함수 표현식 이름 바인딩
  - 대부분 정적 바인딩
  - 값은 바인딩 대상이 아님
- 동적 바인딩
  - 실행 단계에서 바인딩
  - eval함수, with ans

## 54. 바인딩 시점의 중요성
- 바인딩 시점이 중요한 이유
  - 바인딩 할 때 스코프가 결정되기 때문
- Function오브젝트 생성 시점에 스코프 결정
  - 인식한 스코프를 `[[Scope]]`에 설정
  - 정정 바인딩은 `[[Scope]]`를 스코프로 사용
  - `스코프가 변경되지 않음!!!!!!!`
- 같은 단계의 모든 함수의 스코프가 같음
```js
function sports(){
  var prize = 123;
  function soccer() {prize += 123;}
  function baseball(){return prize} // 246반환!!!
}
```

## 55.프로퍼티 검색 방법
- `[[Scope]]`프로퍼티에서 검색
  - 함수를 실행할 때 `[[Scope]]`에서 프로퍼티 이름으로 검색
- 프로퍼티 검색을 위한 추가 처리 필요하지 않음(**함수를 실행할때, 프로퍼티 검색을 위한 추가처리가 없다는 뜻.**)
  - Function 오브젝트를 생성할 때 정적으로 바인딩 하였기 때문
- 처리속도에 영향을 미치지 않음

## 56. 동적 바인딩
- `with문`, `eval()`
- 쓰지말자
- 코드를 실행할 때마다 바인딩

## 57. Lexical Environment
### 사전 이해
- Funtion 오브젝트
  - 오브젝트 생성
  - 오브젝트 프로퍼티
- 함수의 형태
  - 함수 표현식, 선언문
- Argument오브젝트
- 함수, 변수
- 스코프

## 58. 실행 컨텍스트
- 개요
  - 함수의 실행 영역
  - 함수가 올라간 메모리
  - Execution Contexts
  - 함수 코드를 실행하고
  - 실행경과를 저장
  - 엔진을 위한 영역(개발자를 위한 영영x )
  - 컨텍스트 : 묶음, 덩어리
  - 요소가 아님. 이걸 고치려면 전부다 고쳐야 한다.
- ES5 스펙상의 사양
  - 외부 프로그램에서 접근 불가
- 실행 컨텍스트 처리 단계
  - 준비단계
  - 초기화 단계
  - 코드실행 단계

## 59. 실행 컨텍스트
- music('음악'); 형태로 함수를 호출하면
- 엔진은 실행 컨텍스트를 생성하고, 실행 컨텍스트 안으로 이동한다.
- 실행 컨텍스트에서 함수 코드를 해석하고 실행한다.
- 개념적으로 실행 컨텍스트에서 아래 처리를 수행한다. (번호는 순서가 아닌 나열을 위한 것이다. )
(호출하자마자 메모리에 함수가 올라간다. 한번돌고, 두번돌고, 세번도는 걸 메모리에서 처리한다. )
1. music()함수를 호출하면 '음악'을 넘긴다.
